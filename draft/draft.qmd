---
title: "Draft"
author: "Adam Bartonicek"
date: "`r Sys.Date()`"
output: html_document
mainfont: "Liberation Serif"
fontcolor: "#1F271B"
backgroundcolor: "floralwhite"
bibliography: "references.bib"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Interactive visualization is mainly used for communication, not exploration [@batch2017interactive]

```{r}
#| echo: false
#| label: tbl-terms
#| tbl-cap: "Definitions of terms used throughout the thesis"

library(kableExtra)

tab1 <- read.csv('tables/terms.csv')
colnames(tab1) <- c("Term", "Definition", "Examples")
ktab1 <- knitr::kable(tab1)
ktab1 <- column_spec(ktab1, 1, width = "4cm", bold = TRUE)
# ktab1 <- column_spec(ktab1, 2, width = "8cm")

kable_styling(ktab1, bootstrap_options = c("striped"))

```

## What even is interactivity?

Despite the popularity of interactive data visualization, researchers seem to have many different ideas as to what it means for a visualization to be "interactive". For example, Pike et al. [-@pike2009science] note that "interaction" is an overloaded term that can either refer to the concrete tools that users can use to manipulate the visualization, or to the more abstract "human interaction with information" - the back-and-forth between the user's cognition and the visual information presented to them [see also @yi2007toward]. For others, the key measure of interactivity is lag between the user's input and changes to the visualization, with less lag meaning more interactivity [@becker1987brushing; @buja1996interactive], and some make the distinction between "interactive" and "dynamic" manipulation, where interactive manipulation induces change discretely such as by pressing a button or selecting an item from a menu to render a new display, whereas dynamic manipulation induces a real-time, continuous change, for example by smoothly moving a slider or by clicking-and-dragging [@rheingans2002we; @jankun2007model]. Yet for others, the defining features are the ability to query different parts of the dataset (by e.g. zooming and filtering) and that the interactions propagate between "linked" parts of the visualization, for example by brushing points on a scatterplot within a linked scatterplot matrix [@kehrer2012generic; @buja1996interactive, @keim2002information]. Similarly, in Visual Analytics (VA) research, distinction is made between surface-level and parametric interactions, where surface-level interactions manipulate attributes of the visual domain only (e.g. zooming, panning, highlighting), whereas parametric interactions manipulate attributes of mathematical models underlying the visualization [@leman2013visual]. Put simply, the terms "interaction", "interactive", and "interactivity" mean a lot of different things to a lot of different people.

Below, in @tbl-definitions, I have attempted to summarize the main types of interactivity in data visualizations. This list is not supposed to be exhaustive as many more complete and detailed taxonomies of interactive visualizations have been described [see @yi2007toward]. Instead, the point of this list is to provide a rough sketch of the space interactive visualizations live in:

```{r}
#| echo: false
#| label: tbl-definitions
#| tbl-cap: "Definitions of interactivity"

library(kableExtra)

tab1 <- read.csv('tables/definitions.csv')
colnames(tab1) <- c("Type", "Short definition", "Details")
ktab1 <- knitr::kable(tab1)
ktab1 <- column_spec(ktab1, 1, width = "4cm", bold = TRUE)
ktab1 <- column_spec(ktab1, 2, width = "8cm")

kable_styling(ktab1, bootstrap_options = c("striped"))

```

Using the term "interactive" to cover such a wide range of diverse concepts makes it difficult to clearly classify visualizations. For example, should a single scatterplot in which the user can drag a brush to highlight some points be considered "interactive"? Under the most basic definition, yes, since the user *can* affect the visual display through interaction. However, under such an expansive definition, even the process of writing-and-running code to produce a new or altered plot could be considered an exercise in interactive visualization. In contrast, the scatterplot would clearly fail to meet the linked and parametric definitions of interactivity, since with a single plot there's nowhere for the changes to propagate to, and changing the color of individual points can hardly be considered a change to a mathematical model. This highlights the fact that the linked and parametric definitions are quite restrictive, and many visualizations that are currently being called "interactive" would fail to meet them. As for the temporal definition, this is met if we assume the user interaction happens smoothly enough. However, what if the volume of the displayed data is very high and the user has to wait several second before the result of the brushing is rendered? Does the plot stop being interactive (or dynamic) as the result of limited computational resources? Finally, is the plot interactive in the cognitive sense? Perhaps so, if it can help the user generate new insights, however that debatable in light of the limited functionality it has over a static plot. Thus, even with such a simple example, it becomes difficult to determine whether we should label such a plot "interactive" or not. 

The conceptual ambiguity about what "interactivity" is propagates to the software implementations. For example, the [R Graph Gallery entry on Interactive Charts](https://r-graph-gallery.com/interactive-charts.html) [@holtz2022interactive] features several example plots which allow for surface-level user interactions such zooming, panning, hovering, 3D rotation, and node repositioning within a network graph. Crucially, in all of the examples, the user interacts with a single plot and can affect graphical attributes of the plot only, and so these visualizations would not meet the communicating and parametric definitions of interactivity. In contrast, the [Plotly Dash documentation page on Interactive Visualizations](https://dash.plotly.com/interactive-graphing) [@bibentry2022plotly] features examples of linked hovering and cross-filtering, i.e. examples of communicating and parametric interactivity. Somewhat differently again, [VegaLite Gallery pages on Interactive Charts](https://vega.github.io/vega-lite/examples/#interactive-charts) and [Interactive Multiview Displays](https://vega.github.io/vega-lite/examples/#interactive-multi-view-displays)  [@bibentry2022vegalite] feature many examples, only few of which meet the communicating and parametric definitions.

The term "interactive" is very loaded. Clearly, it would not be possible to disambiguate the many different definitions. However, to clear up at least some of the confusion, I propose to use the term *communicating* to refer to visualizations that meet the change propagation definition outlined above. A *communicating visualization* is one whose plots share an underlying representation of the data and communicate together in response to the user's interaction (here used in the essential sense).

## Principled interactivity

In his seminal work, Tufte [-@tufte2001visual] laid out his principles for effective data visualization.

Tufte [-@tufte2001visual] introduced the term *chartjunk* to refer to redundant elements of a plot that do not add anything to the user's ability to extract meaningful patterns from the data, or worse may even outright distract, confuse, or create visual clutter. Tufte went on to document many different types of chartjunk, such as overly aggressive grid-lines, superfluous 3D perspectives, and unintended optical illusions. He also used the term *ducks* to refer to cases when the informative function of a visualization is forcefully subordinated to the aesthetic form. In other words, to cases where the artistics design, real or imagined, is elevated and the data takes a back-seat.

There is even greater potential for ducks and chartjunk to appear in interactive visualizations. First of all, user's interaction can produce abrupt changes to the visual scene and these can be even more attention-grabbing and distracting than any element of a static plot. In cognitive research, it is well-known that visual stimuli are initially perceived pre-attentively and compete for attention [see e.g. @carrasco2011visual; @treue2003visual]. Whichever stimulus is found to be the most salient is then perceived consciously. As such, rapid changes to the visual stimulus can compete for the user's attention and become distracting, especially if they were not committed intentionally.

A specific example of an interactive chartjunk or *interactjunk* may be the overuse of a pop-up tooltips that appears whenever user hovers over a points on a scatterplot. Dragging a cursor over a part of the plot where many such points are located close together will make many tooltips pop in and out of existence and produce a distracting visual clutter. The value of this feature for graphical inference is questionable. Querying individual points *can* be valuable, such as when learning about outliers and otherwise unusual datapoints, however, these are, by definition, few and far apart. Most datapoints do not need to be queried, since they reveal information jointly, as part of a larger pattern. Put simply, we seldom need information about a specific Joe who is average, but information about the Average Joe may be interesting. Conversely, information about a specific Exceptional Steve may be interesting too, but there are few Exceptional Steves, otherwise they would not be exceptional. For these reasons, having a tooltip appear on hover by default seems like a bad feature design. Instead, the appearance of the tooltip should result from an intentional action by the user, such as by clicking the queried point while simultaneously holding down a specific key.

Moreover, tooltip-on-hover also has the hallmarks of an interactive duck: it is immediate, attention-grabbing, and unavoidable. It signals to the user "this is an interactive plot alright".

Finally, a question immediately presents itself: *"does interaction allow the user to see some patterns in the data clearer or faster?"* If not, there is no advantage over static visualization.

```{r}
#| echo: false
#| label: tbl-principles
#| tbl-cap: "Core principles"

library(kableExtra)

tab2 <- read.csv('tables/principles.csv')
ktab2 <- knitr::kable(tab2)
ktab2 <- column_spec(ktab2, 1, width = "12cm", bold = TRUE)

kable_styling(ktab2, bootstrap_options = c("striped"))

```


### The Zebra Problem

One issue with visualizing transient as well as persistent (group) selection is how to display the product of the two types of selection. For example, if we have two persistent groups and a transient selection operator, we end up with six ($= 2 \cdot (2 + 1)$) different visual memberships: base no group, transiently selected no group, base group 1, transiently selected group 1, base group 2, transiently selected group 2. Displaying this many group memberships is tricky. The worst possible solution would be to encode each of these different memberships via a different color (on, for example, a stacked bar chart). Then we would end up with a distracting "zebra" pattern. Also, it may not be immediately clear which colors belong to transient selection and which to persistent selection. We can ameliorate the problem by drawing groups first and then overlaying a semi-transparent color to mark transient selection (i.e. "darkening" or "lightening" the group color if we use black or white overlay).    

```{r}
#| echo: false
#| label: fig-zebra
#| layout-ncol: 3
#| fig-cap: "Zebra Problem"
#| fig-subcap: 
#| - Each color different
#| - Color (group) & \n brightness (transience)
#| - Color (group) & brightness (transience), stacked transience-first

set.seed(123456)
a <- sample(c("A", "B"), 50, replace = TRUE)
b <- sample(1:6, 50, replace = TRUE)

cols1 <- RColorBrewer::brewer.pal(6, "Set1")
cols3 <- c(colorspace::lighten(cols1[1:3], 0.85), cols1[1:3])
cols2 <- cols3[c(1, 4, 2, 5, 3, 6)]

barplot_fun <- function(cols) {
  barplot(table(b, a), col = cols, border = NA, axes = FALSE, 
        xlim = c(0.7 - 0.75, 1.9 + 0.75), ylim = c(0, 35),
        names.arg = c("",""))
  box(col = "grey80")
}

par(mar = c(3, 1, 3, 1))
barplot_fun(cols1)
barplot_fun(cols2)
barplot_fun(cols3)

```
  